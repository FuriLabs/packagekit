From e6cd7e5ef8b24a46aa9dad17bccec4a89090c43f Mon Sep 17 00:00:00 2001
From: Matthias Klumpp <matthias@tenstral.net>
Date: Fri, 27 Jan 2012 15:27:34 +0100
Subject: [PATCH] aptcc: Don't hang on long transactions

The pty we open pipes dpkg's raw output to a file descriptor.
We were never reading this, so when dpkg's stdout/stderr filled
this pipe dpkg would hang waiting for the slave to read some data
off it.
Thanks Jonathan Thomas for the hint!
---
 backends/aptcc/apt.cpp |    4 ++++
 1 files changed, 4 insertions(+), 0 deletions(-)

diff --git a/backends/aptcc/apt.cpp b/backends/aptcc/apt.cpp
index 3c7ca30..36a2a15 100644
--- a/backends/aptcc/apt.cpp
+++ b/backends/aptcc/apt.cpp
@@ -2169,6 +2169,7 @@ cout << "How odd.. The sizes didn't match, email apt@packages.debian.org";
 	// make it nonblocking, verry important otherwise
 	// when the child finish we stay stuck.
 	fcntl(readFromChildFD[0], F_SETFL, O_NONBLOCK);
+	fcntl(pty_master, F_SETFL, O_NONBLOCK);
 
 	// init the timer
 	m_lastTermAction = time(NULL);
@@ -2176,7 +2177,10 @@ cout << "How odd.. The sizes didn't match, email apt@packages.debian.org";
 
 	// Check if the child died
 	int ret;
+	char masterbuf[1024];
 	while (waitpid(m_child_pid, &ret, WNOHANG) == 0) {
+		// TODO: This is dpkg's raw output. Maybe save it for error-solving?
+		while(read(pty_master, masterbuf, sizeof(masterbuf)) > 0);
 		updateInterface(readFromChildFD[0], pty_master);
 	}
 
-- 
1.7.6

