From 2d03c1ed2f710955de4814ddaf8b133da06f026b Mon Sep 17 00:00:00 2001
From: Daniel Nicoletti <dantti85-pk@yahoo.com.br>
Date: Tue, 5 Oct 2010 03:11:39 -0300
Subject: [PATCH] aptcc: Feature: added a fetcher/parser for updates changelogs

---
 backends/aptcc/Makefile.am          |   14 +-
 backends/aptcc/apt-utils.cpp        |  188 ++++++++++++++++++++
 backends/aptcc/apt-utils.h          |   27 +++
 backends/aptcc/apt.cpp              |  327 +++++++++++++++++++++++++++++------
 backends/aptcc/pk-backend-aptcc.cpp |    6 +
 backends/aptcc/pkg_acqfile.cpp      |   38 ++++
 backends/aptcc/pkg_acqfile.h        |   20 ++
 7 files changed, 556 insertions(+), 64 deletions(-)

diff --git a/backends/aptcc/Makefile.am b/backends/aptcc/Makefile.am
index 235b430..4e1e22d 100644
--- a/backends/aptcc/Makefile.am
+++ b/backends/aptcc/Makefile.am
@@ -1,14 +1,14 @@
 plugindir = $(PK_PLUGIN_DIR)
 plugin_LTLIBRARIES = libpk_backend_aptcc.la
-libpk_backend_aptcc_la_SOURCES = pk-backend-aptcc.cpp \
-                                 apt.cpp \
-                                 apt-utils.cpp \
-                                 matcher.cpp \
+libpk_backend_aptcc_la_SOURCES = pkg_acqfile.cpp \
 				 aptcc_show_broken.cpp \
-				 acqprogress.cpp \
 				 aptcc_show_error.cpp \
-				 pkg_acqfile.cpp \
-				 rsources.cpp
+				 apt-utils.cpp \
+				 acqprogress.cpp \
+				 matcher.cpp \
+				 rsources.cpp \
+				 apt.cpp \
+				 pk-backend-aptcc.cpp
 libpk_backend_aptcc_la_LIBADD = -lcrypt $(PK_PLUGIN_LIBS)
 libpk_backend_aptcc_la_LDFLAGS = -module -avoid-version $(APTCC_LIBS) $(GST_LIBS)
 libpk_backend_aptcc_la_CFLAGS = $(PK_PLUGIN_CFLAGS)
diff --git a/backends/aptcc/apt-utils.cpp b/backends/aptcc/apt-utils.cpp
index f2ed478..52142a2 100644
--- a/backends/aptcc/apt-utils.cpp
+++ b/backends/aptcc/apt-utils.cpp
@@ -20,7 +20,11 @@
  */
 
 #include "apt-utils.h"
+
+#include "pkg_acqfile.h"
 #include <iostream>
+#include <fstream>
+#include <sys/stat.h>
 
 static int descrBufferSize = 4096;
 static char *descrBuffer = new char[descrBufferSize];
@@ -240,6 +244,132 @@ get_enum_group (string group)
 	}
 }
 
+string getChangelogFile(const string &name, const string &uri, pkgAcquire *fetcher)
+{
+   string descr("Changelog for ");
+   descr += name;
+
+   // no need to translate this, the changelog is in english anyway
+   string filename = "/tmp/aptcc_changelog";
+
+   new pkgAcqFileSane(fetcher, uri, descr, name, filename);
+   //cerr << "**DEBUG** origin: " << origin() << endl;
+   //cerr << "**DEBUG** uri: " << uri << endl;
+   //cerr << "**DEBUG** filename: " << filename << endl;
+
+   ofstream out(filename.c_str());
+   if(fetcher->Run() == pkgAcquire::Failed) {
+      out << "Failed to download the list of changes. " << endl;
+      out << "Please check your Internet connection." << endl;
+      // FIXME: Need to dequeue the item
+   } else {
+      struct stat filestatus;
+      stat(filename.c_str(), &filestatus );
+      if (filestatus.st_size == 0) {
+         out << "This change is not coming from a source that supports changelogs.\n" << endl;
+         out << "Failed to fetch the changelog for " << name << endl;
+         out << "URI was: " << uri << endl;
+      }
+   };
+   out.close();
+
+   return filename;
+}
+
+string getCVEUrls(const string &changelog)
+{
+    string ret;
+    // Regular expression to find cve references
+    GRegex *regex;
+    GMatchInfo *match_info;
+    regex = g_regex_new("CVE-\\d{4}-\\d{4}",
+                        G_REGEX_CASELESS,
+                        G_REGEX_MATCH_NEWLINE_ANY,
+                        0);
+    g_regex_match (regex, changelog.c_str(), G_REGEX_MATCH_NEWLINE_ANY, &match_info);
+    while (g_match_info_matches(match_info)) {
+        gchar *cve = g_match_info_fetch (match_info, 0);
+        gchar *cveLink;
+        if (!ret.empty()) {
+            ret.append(";");
+        }
+        cveLink = g_strdup_printf("http://web.nvd.nist.gov/view/vuln/detail?vulnId=%s;%s", cve, cve);
+        ret.append(cveLink);
+        g_free(cveLink);
+        g_free(cve);
+        g_match_info_next(match_info, NULL);
+    }
+    g_match_info_free(match_info);
+    g_regex_unref(regex);
+
+    return ret;
+}
+
+string getBugzillaUrls(const string &changelog)
+{
+    string ret;
+    // Matches Ubuntu bugs
+    GRegex *regex;
+    GMatchInfo *match_info;
+    regex = g_regex_new("LP:\\s+(?:[,\\s*]?#(?'bug'\\d+))*",
+                        G_REGEX_CASELESS,
+                        G_REGEX_MATCH_NEWLINE_ANY,
+                        0);
+    g_regex_match (regex, changelog.c_str(), G_REGEX_MATCH_NEWLINE_ANY, &match_info);
+    while (g_match_info_matches(match_info)) {
+        gchar *bug = g_match_info_fetch_named(match_info, "bug");
+        gchar *bugLink;
+        if (!ret.empty()) {
+            ret.append(";");
+        }
+        bugLink = g_strdup_printf("https://bugs.launchpad.net/bugs/%s;Launchpad bug #%s", bug, bug);
+        ret.append(bugLink);
+        g_free(bugLink);
+        g_free(bug);
+        g_match_info_next(match_info, NULL);
+    }
+    g_match_info_free(match_info);
+    g_regex_unref(regex);
+
+    // Debian bugs
+    // Regular expressions to detect bug numbers in changelogs according to the
+    // Debian Policy Chapter 4.4. For details see the footnote 15:
+    // http://www.debian.org/doc/debian-policy/footnotes.html#f15
+    // /closes:\s*(?:bug)?\#?\s?\d+(?:,\s*(?:bug)?\#?\s?\d+)*/i
+    regex = g_regex_new("closes:\\s*(?:bug)?\\#?\\s?(?'bug1'\\d+)(?:,\\s*(?:bug)?\\#?\\s?(?'bug2'\\d+))*",
+                        G_REGEX_CASELESS,
+                        G_REGEX_MATCH_NEWLINE_ANY,
+                        0);
+    g_regex_match (regex, changelog.c_str(), G_REGEX_MATCH_NEWLINE_ANY, &match_info);
+    while (g_match_info_matches(match_info)) {
+        gchar *bug1 = g_match_info_fetch_named(match_info, "bug1");
+        gchar *bugLink1;
+        if (!ret.empty()) {
+            ret.append(";");
+        }
+        bugLink1 = g_strdup_printf("http://bugs.debian.org/cgi-bin/bugreport.cgi?bug=%s;Debian bug #%s", bug1, bug1);
+        ret.append(bugLink1);
+
+        gchar *bug2 = g_match_info_fetch_named(match_info, "bug2");
+        if (!ret.empty() && bug2 != NULL) {
+            gchar *bugLink2;
+            ret.append(";");
+            bugLink2 = g_strdup_printf("http://bugs.debian.org/cgi-bin/bugreport.cgi?bug=%s;Debian bug #%s", bug1, bug1);
+            ret.append(bugLink2);
+            g_free(bugLink2);
+            g_free(bug2);
+        }
+
+        g_free(bugLink1);
+        g_free(bug1);
+        g_match_info_next(match_info, NULL);
+    }
+    g_match_info_free(match_info);
+    g_regex_unref(regex);
+
+    return ret;
+}
+
 bool contains(vector<pair<pkgCache::PkgIterator, pkgCache::VerIterator> > packages,
 	    const pkgCache::PkgIterator pkg)
 {
@@ -265,3 +395,61 @@ bool starts_with (const string &str, const char *start)
 	return str.size() >= startSize && (strncmp(str.data(), start, startSize) == 0);
 }
 
+GDateTime* dateFromString(const gchar *tz,
+                          const gchar *year,
+                          const gchar *month,
+                          const gchar *day,
+                          const gchar *hour,
+                          const gchar *minute,
+                          const gchar *seconds)
+{
+    GDateTime *ret;
+    int monthI;
+    if (strcmp(month, "Jan") == 0) {
+        monthI = 1;
+    } else if (strcmp(month, "Feb") == 0) {
+        monthI = 2;
+    } else if (strcmp(month, "Mar") == 0) {
+        monthI = 3;
+    } else if (strcmp(month, "Apr") == 0) {
+        monthI = 4;
+    } else if (strcmp(month, "May") == 0) {
+        monthI = 5;
+    } else if (strcmp(month, "Jun") == 0) {
+        monthI = 6;
+    } else if (strcmp(month, "Jul") == 0) {
+        monthI = 7;
+    } else if (strcmp(month, "Aug") == 0) {
+        monthI = 8;
+    } else if (strcmp(month, "Sep") == 0) {
+        monthI = 9;
+    } else if (strcmp(month, "Oct") == 0) {
+        monthI = 10;
+    } else if (strcmp(month, "Nov") == 0) {
+        monthI = 11;
+    } else if (strcmp(month, "Dez") == 0) {
+        monthI = 12;
+    }
+
+    ret = g_date_time_new(g_time_zone_new(tz),
+                          atoi(year),
+                          monthI,
+                          atoi(day),
+                          atoi(hour),
+                          atoi(minute),
+                          atoi(seconds));
+    return ret;
+}
+
+const char *utf8(const char *str)
+{
+   static char *_str = NULL;
+   if (str == NULL)
+      return NULL;
+   if (g_utf8_validate(str, -1, NULL) == true)
+      return str;
+   g_free(_str);
+   _str = NULL;
+   _str = g_locale_to_utf8(str, -1, NULL, NULL, NULL);
+   return _str;
+}
diff --git a/backends/aptcc/apt-utils.h b/backends/aptcc/apt-utils.h
index 92f6e1a..461e7ca 100644
--- a/backends/aptcc/apt-utils.h
+++ b/backends/aptcc/apt-utils.h
@@ -104,6 +104,21 @@ string get_long_description_parsed(const pkgCache::VerIterator &ver,
 PkGroupEnum get_enum_group(string group);
 
 /**
+  * Return the changelog filename fetched
+  */
+string getChangelogFile(const string &name, const string &uri, pkgAcquire *fetcher);
+
+/**
+  * Returns a list of links pairs url;description for CVEs
+  */
+string getCVEUrls(const string &changelog);
+
+/**
+  * Returns a list of links pairs url;description for Debian and Ubuntu bugs
+  */
+string getBugzillaUrls(const string &changelog);
+
+/**
   * Return if the given vector contain a package
   */
 bool contains(vector<pair<pkgCache::PkgIterator, pkgCache::VerIterator> > packages,
@@ -119,4 +134,16 @@ bool ends_with(const string &str, const char *end);
   */
 bool starts_with(const string &str, const char *end);
 
+GDateTime* dateFromString(const gchar *tz,
+                          const gchar *year,
+                          const gchar *month,
+                          const gchar *day,
+                          const gchar *hour,
+                          const gchar *minute,
+                          const gchar *seconds);
+/**
+  * Return an utf8 string
+  */
+const char *utf8(const char *str);
+
 #endif
diff --git a/backends/aptcc/apt.cpp b/backends/aptcc/apt.cpp
index c4089de..c0c58e2 100644
--- a/backends/aptcc/apt.cpp
+++ b/backends/aptcc/apt.cpp
@@ -31,8 +31,10 @@
 #include <apt-pkg/tagfile.h>
 #include <apt-pkg/algorithms.h>
 #include <apt-pkg/init.h>
-
 #include <apt-pkg/sptr.h>
+#include <apt-pkg/pkgsystem.h>
+#include <apt-pkg/version.h>
+
 #include <sys/statvfs.h>
 #include <sys/statfs.h>
 #include <sys/wait.h>
@@ -584,49 +586,260 @@ void aptcc::emit_details(const pkgCache::PkgIterator &pkg)
 // used to emit packages it collects all the needed info
 void aptcc::emit_update_detail(const pkgCache::PkgIterator &pkg)
 {
-	pkgCache::VerIterator candver = find_candidate_ver(pkg);
-
-	pkgCache::VerFileIterator vf = candver.FileList();
-	pkgRecords::Parser &rec = packageRecords->Lookup(vf);
-	string archive(vf.File().Archive());
-	gchar *package_id;
-	package_id = pk_package_id_build(pkg.Name(),
-					candver.VerStr(),
-					candver.Arch(),
-					archive.c_str());
-
-	pkgCache::VerIterator currver = find_ver(pkg);
-	pkgCache::VerFileIterator currvf = currver.FileList();
-	gchar *current_package_id;
-	current_package_id = pk_package_id_build(pkg.Name(),
-						currver.VerStr(),
-						currver.Arch(),
-						currvf.File().Archive());
-
-	PkUpdateStateEnum updateState = PK_UPDATE_STATE_ENUM_UNKNOWN;
-	if (archive.compare("stable") == 0) {
-		updateState = PK_UPDATE_STATE_ENUM_STABLE;
-	} else if (archive.compare("testing") == 0) {
-		updateState = PK_UPDATE_STATE_ENUM_TESTING;
-	} else if (archive.compare("unstable")  == 0 ||
-		archive.compare("experimental") == 0)
-	{
-		updateState = PK_UPDATE_STATE_ENUM_UNSTABLE;
-	}
-	pk_backend_update_detail(m_backend,
-				 package_id,
-				 current_package_id,//const gchar *updates
-				 "",//const gchar *obsoletes
-				 "",//const gchar *vendor_url
-				 "",//const gchar *bugzilla_url
-				 "",//const gchar *cve_url
-				 PK_RESTART_ENUM_NONE,//PkRestartEnum restart
-				 "",//const gchar *update_text
-				 "",//const gchar *changelog
-				 updateState,//PkUpdateStateEnum state
-				 "",//const gchar *issued_text
-				 ""//const gchar *updated_text
-				 );
+    // Get the version of the current package
+    pkgCache::VerIterator     currver = find_ver(pkg);
+    pkgCache::VerFileIterator currvf  = currver.FileList();
+    // Build a package_id from the current version
+    gchar *current_package_id;
+    current_package_id = pk_package_id_build(pkg.Name(),
+                                             currver.VerStr(),
+                                             currver.Arch(),
+                                             currvf.File().Archive());
+
+    // Get the update version
+    pkgCache::VerIterator candver = find_candidate_ver(pkg);
+
+    pkgCache::VerFileIterator vf = candver.FileList();
+    pkgCache::PkgFileIterator pkgFile = vf.File();
+    string origin = pkgFile.Origin();
+    pkgRecords::Parser &rec = packageRecords->Lookup(candver.FileList());
+
+    // Build the changelogURI
+    char uri[512];
+    string srcpkg;
+
+    if (rec.SourcePkg().empty()) {
+        srcpkg = pkg.Name();
+    } else {
+        srcpkg = rec.SourcePkg();
+    }
+    if (origin.compare("Debian") == 0 || origin.compare("Ubuntu") == 0) {
+        string prefix;
+
+        string src_section = candver.Section();
+        if(src_section.find('/') != src_section.npos) {
+            src_section = string(src_section, 0, src_section.find('/'));
+        } else {
+            src_section = "main";
+        }
+
+        prefix+=srcpkg[0];
+        if(srcpkg.size() > 3 && srcpkg[0] == 'l' && srcpkg[1] == 'i' && srcpkg[2] == 'b') {
+            prefix = string("lib") + srcpkg[3];
+        }
+
+        string verstr;
+        if(candver.VerStr() != NULL) {
+            verstr = candver.VerStr();
+        }
+
+        if(verstr.find(':') != verstr.npos) {
+            verstr=string(verstr, verstr.find(':') + 1);
+        }
+
+        if (origin.compare("Debian") == 0) {
+            snprintf(uri,
+                        512,
+                        "http://packages.debian.org/changelogs/pool/%s/%s/%s/%s_%s/changelog",                                    src_section.c_str(),
+                        prefix.c_str(),
+                        srcpkg.c_str(),
+                        srcpkg.c_str(),
+                        verstr.c_str());
+        } else {
+            snprintf(uri,
+                        512,
+                        "http://changelogs.ubuntu.com/changelogs/pool/%s/%s/%s/%s_%s/changelog",                                    src_section.c_str(),
+                        prefix.c_str(),
+                        srcpkg.c_str(),
+                        srcpkg.c_str(),
+                        verstr.c_str());
+        }
+    } else {
+        string pkgfilename;
+        const char *start, *stop;
+        pkgTagSection sec;
+        unsigned long len;
+
+        rec.GetRec(start, stop);
+        len = stop - start;
+        // add +1 to ensure we have the double lineline in the buffer
+        if (start && sec.Scan(start, len + 1)) {
+            pkgfilename = sec.FindS("Filename");
+        }
+
+        string cadidateOriginSiteUrl;
+        if(!vf.end() && vf.File() && vf.File().Site()) {
+            cadidateOriginSiteUrl = vf.File().Site();
+        }
+
+        pkgfilename = pkgfilename.substr(0, pkgfilename.find_last_of('.')) + ".changelog";
+        snprintf(uri,512,"http://%s/%s",
+                cadidateOriginSiteUrl.c_str(),
+                pkgfilename.c_str());
+    }
+    // Create the download object
+    AcqPackageKitStatus Stat(this, m_backend, _cancel);
+
+    // get a fetcher
+    pkgAcquire fetcher;
+    fetcher.Setup(&Stat);
+
+    // fetch the changelog
+    string filename = getChangelogFile(pkg.Name(), uri, &fetcher);
+
+    string changelog;
+    string update_text;
+    ifstream in(filename.c_str());
+    string line;
+    GRegex *regexVer;
+    regexVer = g_regex_new("(?'source'.+) \\((?'version'.*)\\) "
+                           "(?'dist'.+); urgency=(?'urgency'.+)",
+                           G_REGEX_CASELESS,
+                           G_REGEX_MATCH_ANCHORED,
+                           0);
+    GRegex *regexDate;
+    regexDate = g_regex_new("^ -- (?'maintainer'.+) (?'mail'<.+>)  (?'dayname'\\w+,) "
+"(?'d'\\d+) (?'m'\\w+) (?'y'\\d+) (?'H'\\d+):(?'M'\\d+):(?'s'\\d+) (?'offset'[-\\+]\\d+)$",
+                            G_REGEX_CASELESS,
+                            G_REGEX_MATCH_ANCHORED,
+                            0);
+    string updated;
+    string issued;
+    while (getline(in, line)) {
+        // no need to free str later, it is allocated in a static buffer
+        const char *str = utf8(line.c_str());
+        if (strcmp(str, "") == 0) {
+            changelog.append("\n");
+            continue;
+        } else {
+            changelog.append(str);
+            changelog.append("\n");
+        }
+
+        if (starts_with(str, srcpkg.c_str())) {
+            // Check to see if the the text isn't about the current package,
+            // otherwise add a == version ==
+            GMatchInfo *match_info;
+            if (g_regex_match(regexVer, str, G_REGEX_MATCH_ANCHORED, &match_info)) {
+                gchar *version;
+                version = g_match_info_fetch_named(match_info, "version");
+
+                // Compare if the current version is shown in the changelog, to not
+                // display old changelog information
+                if (_system != 0  &&
+                    _system->VS->DoCmpVersion(version, version + strlen(version),
+                                              currver.VerStr(), currver.VerStr() + strlen(currver.VerStr())) <= 0) {
+                    g_free (version);
+                    break;
+                } else {
+                    if (!update_text.empty()) {
+                        update_text.append("\n\n");
+                    }
+                    update_text.append(" == ");
+                    update_text.append(version);
+                    update_text.append(" ==");
+                    g_free (version);
+                }
+            }
+            g_match_info_free (match_info);
+        } else if (starts_with(str, "  ")) {
+            // update descritption
+            update_text.append("\n");
+            update_text.append(str);
+        } else if (starts_with(str, " --")) {
+            // Parse the text to know when the update was issued,
+            // and when it got updated
+            GMatchInfo *match_info;
+            if (g_regex_match(regexDate, str, G_REGEX_MATCH_ANCHORED, &match_info)) {
+                gchar *tz;
+                gchar *year;
+                gchar *month;
+                gchar *day;
+                gchar *hour;
+                gchar *minute;
+                gchar *seconds;
+                tz = g_match_info_fetch_named(match_info, "offset");
+                year = g_match_info_fetch_named(match_info, "y");
+                month = g_match_info_fetch_named(match_info, "m");
+                day = g_match_info_fetch_named(match_info, "d");
+                hour = g_match_info_fetch_named(match_info, "H");
+                minute = g_match_info_fetch_named(match_info, "M");
+                seconds = g_match_info_fetch_named(match_info, "s");
+                GDateTime *dateTime;
+                dateTime = dateFromString(tz,
+                                          year,
+                                          month,
+                                          day,
+                                          hour,
+                                          minute,
+                                          seconds);
+                g_free(tz);
+                g_free(year);
+                g_free(month);
+                g_free(day);
+                g_free(hour);
+                g_free(minute);
+                g_free(seconds);
+
+                issued = g_date_time_format(dateTime, "%FT%R:%S");
+                if (updated.empty()) {
+                    updated = g_date_time_format(dateTime, "%FT%R:%S");
+                }
+            }
+            g_match_info_free(match_info);
+        }
+    }
+    // Clean structures
+    g_regex_unref(regexVer);
+    g_regex_unref(regexDate);
+    unlink(filename.c_str());
+
+    // Check if the update was updates since it was issued
+    if (issued.compare(updated) == 0) {
+        updated = "";
+    }
+
+    // Build a package_id from the update version
+    string archive(vf.File().Archive());
+    gchar *package_id;
+    package_id = pk_package_id_build(pkg.Name(),
+                    candver.VerStr(),
+                    candver.Arch(),
+                    archive.c_str());
+
+    PkUpdateStateEnum updateState = PK_UPDATE_STATE_ENUM_UNKNOWN;
+    if (archive.compare("stable") == 0) {
+        updateState = PK_UPDATE_STATE_ENUM_STABLE;
+    } else if (archive.compare("testing") == 0) {
+        updateState = PK_UPDATE_STATE_ENUM_TESTING;
+    } else if (archive.compare("unstable")  == 0 ||
+        archive.compare("experimental") == 0)
+    {
+        updateState = PK_UPDATE_STATE_ENUM_UNSTABLE;
+    }
+
+    PkRestartEnum restart = PK_RESTART_ENUM_NONE;
+    if (starts_with(pkg.Name(), "linux-image-") ||
+        starts_with(pkg.Name(), "nvidia-") ||
+        strcmp(pkg.Name(), "libc6") == 0 ||
+        strcmp(pkg.Name(), "dbus") == 0) {
+        restart = PK_RESTART_ENUM_SYSTEM;
+    }
+
+    pk_backend_update_detail(m_backend,
+                             package_id,
+                             current_package_id,//const gchar *updates
+                             "",//const gchar *obsoletes
+                             "",//const gchar *vendor_url
+                             getBugzillaUrls(changelog).c_str(),//const gchar *bugzilla_url
+                             getCVEUrls(changelog).c_str(),//const gchar *cve_url
+                             restart,//PkRestartEnum restart
+                             update_text.c_str(),//const gchar *update_text
+                             changelog.c_str(),//const gchar *changelog
+                             updateState,//PkUpdateStateEnum state
+                             issued.c_str(), //const gchar *issued_text
+                             updated.c_str() //const gchar *updated_text
+                             );
 }
 
 void aptcc::get_depends(vector<pair<pkgCache::PkgIterator, pkgCache::VerIterator> > &output,
@@ -1286,34 +1499,34 @@ void aptcc::updateInterface(int fd, int writeFd)
 				// Let's start parsing the status:
 				if (starts_with(str, "Preparing to configure")) {
 					// Preparing to Install/configure
-					cout << "Found Preparing to configure! " << line << endl;
+// 					cout << "Found Preparing to configure! " << line << endl;
 					// The next item might be Configuring so better it be 100
 					m_lastSubProgress = 100;
 					emitTransactionPackage(pkg, PK_INFO_ENUM_PREPARING);
 					pk_backend_set_sub_percentage(m_backend, 75);
 				} else if (starts_with(str, "Preparing for removal")) {
 					// Preparing to Install/configure
-					cout << "Found Preparing for removal! " << line << endl;
+// 					cout << "Found Preparing for removal! " << line << endl;
 					m_lastSubProgress = 50;
 					emitTransactionPackage(pkg, PK_INFO_ENUM_REMOVING);
 					pk_backend_set_sub_percentage(m_backend, m_lastSubProgress);
 				} else if (starts_with(str, "Preparing")) {
 					// Preparing to Install/configure
-					cout << "Found Preparing! " << line << endl;
+// 					cout << "Found Preparing! " << line << endl;
 					// if last package is different then finish it
 					if (!m_lastPackage.empty() && m_lastPackage.compare(pkg) != 0) {
-						cout << "FINISH the last package: " << m_lastPackage << endl;
+// 						cout << "FINISH the last package: " << m_lastPackage << endl;
 						emitTransactionPackage(m_lastPackage, PK_INFO_ENUM_FINISHED);
 					}
 					emitTransactionPackage(pkg, PK_INFO_ENUM_PREPARING);
 					pk_backend_set_sub_percentage(m_backend, 25);
 				} else if (starts_with(str, "Unpacking")) {
-					cout << "Found Unpacking! " << line << endl;
+// 					cout << "Found Unpacking! " << line << endl;
 					emitTransactionPackage(pkg, PK_INFO_ENUM_DECOMPRESSING);
 					pk_backend_set_sub_percentage(m_backend, 50);
 				} else if (starts_with(str, "Configuring")) {
 					// Installing Package
-					cout << "Found Configuring! " << line << endl;
+// 					cout << "Found Configuring! " << line << endl;
 					if (m_lastSubProgress >= 100 && !m_lastPackage.empty()) {
 						cout << "FINISH the last package: " << m_lastPackage << endl;
 						emitTransactionPackage(m_lastPackage, PK_INFO_ENUM_FINISHED);
@@ -1323,24 +1536,24 @@ void aptcc::updateInterface(int fd, int writeFd)
 					pk_backend_set_sub_percentage(m_backend, m_lastSubProgress);
 					m_lastSubProgress += 25;
 				} else if (starts_with(str, "Running dpkg")) {
-					cout << "Found Running dpkg! " << line << endl;
+// 					cout << "Found Running dpkg! " << line << endl;
 				} else if (starts_with(str, "Running")) {
-					cout << "Found Running! " << line << endl;
+// 					cout << "Found Running! " << line << endl;
 					pk_backend_set_status (m_backend, PK_STATUS_ENUM_COMMIT);
 				} else if (starts_with(str, "Installing")) {
-					cout << "Found Installing! " << line << endl;
+// 					cout << "Found Installing! " << line << endl;
 					// FINISH the last package
 					if (!m_lastPackage.empty()) {
-						cout << "FINISH the last package: " << m_lastPackage << endl;
+// 						cout << "FINISH the last package: " << m_lastPackage << endl;
 						emitTransactionPackage(m_lastPackage, PK_INFO_ENUM_FINISHED);
 					}
 					m_lastSubProgress = 0;
 					emitTransactionPackage(pkg, PK_INFO_ENUM_INSTALLING);
 					pk_backend_set_sub_percentage(m_backend, 0);
 				} else if (starts_with(str, "Removing")) {
-					cout << "Found Removing! " << line << endl;
+// 					cout << "Found Removing! " << line << endl;
 					if (m_lastSubProgress >= 100 && !m_lastPackage.empty()) {
-						cout << "FINISH the last package: " << m_lastPackage << endl;
+// 						cout << "FINISH the last package: " << m_lastPackage << endl;
 						emitTransactionPackage(m_lastPackage, PK_INFO_ENUM_FINISHED);
 					}
 					m_lastSubProgress += 25;
@@ -1348,7 +1561,7 @@ void aptcc::updateInterface(int fd, int writeFd)
 					pk_backend_set_sub_percentage(m_backend, m_lastSubProgress);
 				} else if (starts_with(str, "Installed") ||
 					       starts_with(str, "Removed")) {
-					cout << "Found FINISHED! " << line << endl;
+// 					cout << "Found FINISHED! " << line << endl;
 					m_lastSubProgress = 100;
 					emitTransactionPackage(pkg, PK_INFO_ENUM_FINISHED);
 				} else {
diff --git a/backends/aptcc/pk-backend-aptcc.cpp b/backends/aptcc/pk-backend-aptcc.cpp
index f4f80d5..246a4c0 100644
--- a/backends/aptcc/pk-backend-aptcc.cpp
+++ b/backends/aptcc/pk-backend-aptcc.cpp
@@ -321,6 +321,12 @@ backend_get_details_thread (PkBackend *backend)
 		return false;
 	}
 
+    if (updateDetail) {
+        // this is needed to compare the changelog verstion to
+        // current package using DoCmpVersion()
+        pkgInitSystem(*_config, _system);
+    }
+
 	pk_backend_set_status (backend, PK_STATUS_ENUM_QUERY);
 	for (uint i = 0; i < g_strv_length(package_ids); i++) {
 		pi = package_ids[i];
diff --git a/backends/aptcc/pkg_acqfile.cpp b/backends/aptcc/pkg_acqfile.cpp
index 2f64d16..872816b 100644
--- a/backends/aptcc/pkg_acqfile.cpp
+++ b/backends/aptcc/pkg_acqfile.cpp
@@ -33,10 +33,48 @@
 #include <sys/stat.h>
 
 #include <apt-pkg/error.h>
+#include <apt-pkg/configuration.h>
 #include <apt-pkg/acquire-item.h>
 #include <apt-pkg/sourcelist.h>
 #include <apt-pkg/strutl.h>
 
+// Let's all sing a song about apt-pkg's brokenness..
+
+pkgAcqFileSane::pkgAcqFileSane(pkgAcquire *Owner, string URI,
+                   string Description, string ShortDesc,
+                   string filename):
+  Item(Owner)
+{
+  Retries=_config->FindI("Acquire::Retries",0);
+  DestFile=filename;
+
+  Desc.URI=URI;
+  Desc.Description=Description;
+  Desc.Owner=this;
+  Desc.ShortDesc=ShortDesc;
+
+  QueueURI(Desc);
+}
+
+// Straight from acquire-item.cc
+/* Here we try other sources */
+void pkgAcqFileSane::Failed(string Message,pkgAcquire::MethodConfig *Cnf)
+{
+  ErrorText = LookupTag(Message,"Message");
+
+  // This is the retry counter
+  if (Retries != 0 &&
+      Cnf->LocalOnly == false &&
+      StringToBool(LookupTag(Message,"Transient-Failure"),false) == true)
+    {
+      Retries--;
+      QueueURI(Desc);
+      return;
+    }
+
+  Item::Failed(Message,Cnf);
+}
+
 // Mostly copied from pkgAcqArchive.
 bool get_archive(pkgAcquire *Owner, pkgSourceList *Sources,
 		pkgRecords *Recs, pkgCache::VerIterator const &Version,
diff --git a/backends/aptcc/pkg_acqfile.h b/backends/aptcc/pkg_acqfile.h
index 08fe02f..a6638b7 100644
--- a/backends/aptcc/pkg_acqfile.h
+++ b/backends/aptcc/pkg_acqfile.h
@@ -22,6 +22,26 @@
 /** \file pkg_acqfile.h
  */
 
+class pkgAcqFileSane:public pkgAcquire::Item
+// This is frustrating: pkgAcqFile is **almost** good enough, but has some
+// hardcoded stuff that makes it not quite work.
+//
+//  Based heavily on that class, though.
+{
+  pkgAcquire::ItemDesc Desc;
+  string Md5Hash;
+  unsigned int Retries;
+
+public:
+  pkgAcqFileSane(pkgAcquire *Owner, string URI,
+         string Description, string ShortDesc, string filename);
+
+  void Failed(string Message, pkgAcquire::MethodConfig *Cnf);
+  string MD5Sum() {return Md5Hash;}
+  string DescURI() {return Desc.URI;}
+  virtual ~pkgAcqFileSane() {}
+};
+
 /** Like pkgAcqArchive, but uses generic File objects to download to
  *  the cwd (and copies from file:/ URLs).
  */
-- 
1.6.1

